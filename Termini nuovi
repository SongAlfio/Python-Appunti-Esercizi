Python
print serve a dimostrare uno o più risultati
Slicing: recupera una parte di lista sul python. 从列表中截取一段.
https://www.runoob.com/wp-content/uploads/2013/11/o99aU.png
list comprehension: costruiamo una lista scrivendo delle parentesi quadre, per fare il looping e le operazione matimatiche. (for)
Indexing: trova un posto nella lista.
tuple（元组）: dentro il tuple, l'elemento può solo essere letto, ma non può essere cambiato.
dictionary（字典）: è composto da keys e values. 字典由索引(key)和它对应的值value组成
semplice operazione aritmetica:  round( ): Arrotondamento，abs(): Numero assoluto
Formatting(格式化):capitalize()=头字母大写，title()=每个词头字母大写，upper()=全大写，lower()=全小写，swapped()=调反大小写
len Funzione che ti dice quanti elementi è presente nella stringa.
count: è usato per contare quante volte è presente nella lista.
max prende il valore massimo della lista
min prende il valore minimo della lista
set: elimina gli elementi che compare più volte e si cambia l'ordine.
zip(): è usato per compressione di due liste per formare un dizionario.
times(x,y): usato per multiplicazione di due valori.
Funzione: è un costrutto sintatico che permette di raggruppare un insieme di istruzioni. Una funzione può avere 0 o più parametri(argomenti). Una funzioene deve avere anche dei valori di uscita.
parametro formale: dietro il "def", la parte dentro la parentesi
parametro attuale: codice di esecuzione
la funzine deve essere senza "input" e senza "print"
"map" è una funzione che applica ad ogni elemento una lista(secondo parametro) una funzione
"filter" è una funzione che filtra l'elemento che hai inserito
lambda: il "x" è il parametro. il ": " significa sostituisce


Pandas
df = pd.read serve a leggere un documento
XXX = pd.dataframe serve a creare un dataframe
df.head per le prime righe del dataframe
df.tail per le ultime righe del dataframe
iloc serve a localizzare la colonna con i numeri([:])
loc serve a localizzare la colonna con le condizioni
sort_values serve a ordinare la dataframe, e ascending serve a mettere in ordine crescente
drop serve ad eliminare le righe o le colonne
str.contains si usa per trovare le parole che contiene la specifica lettera o parola
str.startswith si usa per trovare le parole che si iniziano con la specifica lettera o parola, c'è anche endswith
se vuoi trovare più di una colonna devi fare una lista(mettere un [] in più).
%%time serve a vedere quanto tempo ci vuole per eseguire quel commando.
groupby.first serve a mettere nel primo posto la colonna inserita
sum serve a sommare i numeri nelle colonne
il mean si usa per fare la media di numeri in dataframe
df.to_excel('./file.xlsx') serve a creare un documento di tipo xlsx
df.to_csv('./file.csv') serve a creare un documento di tipo csv
df.to_json('./file.json') serve a creare un documento di tipo json
df.info serve a vedere le informazioni della dataframe


MatPlotlib
possono essere diverse linee come: "m.", "r", "m--" ecc...
plt.figure serve a creare il grafico
ax.set_xlabel serve a nominare l'asse x
ax.set_ylabel serve a nominare l'asse y
suptitle serve a nominare il titolo del grafico(sopra)
show serve a dimostrare il grafico
ax.pie serve a fare la grafico a torta
bar serve a fare il grafico a barre
barh serve a fare il grafico a barre orrizontale
fig.set_figwidth Regola la larghezza del grafico
fig.set_figheight Regola l'altezza del grafico
fig.autofmt_xdate(rotation=90) Modifica la rotazione dei nomi dell'asse X
ax.set_ylim([0, 20000000]) Cambia il limite dei valori sull'asse Y
ax.set_yticklabels(np.arange(0, 20000001, step=2000000)) Cambia i nomi dei valori riportati sull'asse Y
ax.set_yticks(np.arange(0, 20000001, step=2000000)) Cambia la frequenza con cui viene visualizzato un nome sull'asse Y


Geopandas
Prima di fare qualsiasi cosa dobbiamo installare(!pip install) e importare geopandas
Per leggere un file zippato si usa Geopandas.read_file('...')
type è usato per vedere il tipo di dataframe 
conxtily è una mappa che ha il epsg di 3857
per funzionare il contextily dobbiamo usare to_crs()
per ordinare il geodataframe possiamo usare: geopandas.sort_values(by='AREA',ascending=False)
geometry è usato per vedere la tipologia della forma,geometry.area per vedere l'area di quel luogo
per avere i colori diversi per ogni luogo possiamo usare il "legend"(colunm='',legend=True) 
squeeze è usato per tirare la figura dalla mappa, diventa un'unica figura
unary_union serve a unire più forme di figura in un'unica figura
alpha serve a far diventare trasparente la figura.
add_basemap serve a creare la mappa di base usando il contextily
dentro il basemap possiamo cambiare lo stile della mappa usando il source
posssiamo mettere una figura il un'altra figura usando ax=ax
edgecolor è usato per scegliere il colore del bordo
facecolor è usato per scegliere il colore dell'area
Quando compare "The indices of the two GeoSeries are different", dobbiamo usare Geometry.squeeze o unary.union
Buffer è usato per ingrandire la figura geometrica
quando dobbiamo controllare se un elemento è nella geodataframe, possiamo usare "not in list(dataframe['colonna'])"
intersects significa che due figure si intersecano
touches significa che le due figure si toccano
within significa che un elemento è dentro in un'altro elemento
intersection ci fa vedere solo la parte che è interseccato con un'altro elemento
union ci fa vedere tutta la parte unita
difference ci fa vedere la parte non sovrapposto
se dobbiamo leggere un excel di tipo xls dobbiamo usare questi codici:
! pip install xlrd==1.2.0
import xlrd


Geopandas Join spaziali
possiamo usare pd.merge per unire 2 dataframe / 1 dataframe+ 1 geodataframe / 2 geodataframe che hanno le simile colonne
nel pd.merge dobbiamo usare il how con 4 modi: "right" si pentende a destra, "left" si pentende a sinistra, "outer" si unisce tutti i dati dei due dataframe/geodataframe, "inner" si unisce solo i dati che esistono in tutti due dataframe/geodataframe.
pd.merge si usa anche il on, che significa i 2 dataframe/geodataframe si uniscono dipende da quella colonna, si può usare anche right_on e left_on
quando dobbiamo fare i grafici possiamo usare Sjoin solo a 2 geodataframe
ma prima di usare sjoin dobbiamo eseguire questi codici per installare rtree, import modulo os è installazione di rtree e altro per far funzionare l'sjoin:

import os
!pip install rtree
!curl -L http://download.osgeo.org/libspatialindex/spatialindex-src-1.8.5.tar.gz | tar xz
os.chdir("/content/spatialindex-src-1.8.5")
!./configure
!make
!make install
!ldconfig

nel sjoin dobbiamo usare op per il posizione come "within" che serviamo a dire che un geodataframe è dentro a l'altra geodataframe, possiamo usare anche intersects ecc...
nel sjoin il how funziona solo con "left" e "outer"
per trasformare una colonna da object a intero possiamo fare(esempio):

Bike_Area2 = Bike_Area.drop(Bike_Area[Bike_Area['id_via'].isnull()].index)
Bike_Area2['id_via'] = Bike_Area2['id_via'].astype(int)

possiamo usare .isin per vedere se un luogo contiene quello luogho
as type ci serve a convertire il tipo di documento
